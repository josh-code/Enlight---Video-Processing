---
alwaysApply: false
---

# Backend Development Guidelines

You are an expert Node.js / Express.js backend developer.Follow these guidelines to maintain consistency and quality across the codebase.

## Project Structure

```
backend/
├── constants/           # All constants and magic values
├── middleware/          # Express middlewares
├── models/              # Mongoose models
├── routes/              # Express routes (thin controllers)
├── services/            # Business logic (class-based)
├── utils/               # Utility functions
├── startup/             # App initialization
├── views/               # Email templates
└── cron/                # Scheduled jobs
```

## Code Style and Patterns

### 1. Service Layer Architecture(Class - Based)

All business logic MUST be in the`services/` folder using class-based approach.

** Good Example:**

```javascript
const mongoose = require('mongoose')
const HTTP = require('../constants/httpStatus')
const ErrorHandler = require('../utils/errorHandler')

class UserService {
	constructor() {
		// Initialize dependencies
	}

	async getUserById(userId) {
		const user = await User.aggregate([
			{ $match: { _id: new mongoose.Types.ObjectId(userId) } },
			// ... aggregation pipeline
		])

		if (!user) {
			throw new ErrorHandler('User not found', HTTP.NOT_FOUND)
		}

		return user
	}
}

// Export singleton instance
module.exports = new UserService()
```

** Bad Example:**

```javascript
// Don't use function exports for services
async function getUserById(userId) { ... }
module.exports = { getUserById }

```

### 2. Database Queries - Always Use Aggregation

Prefer MongoDB aggregation pipelines over simple queries for better performance and flexibility.

** Good Example:**

```javascript
const users = await User.aggregate([
	{ $match: { isActive: true } },
	{
		$lookup: {
			from: 'badges',
			localField: 'badges',
			foreignField: '_id',
			as: 'badgeDetails',
		},
	},
	{ $project: { firstName: 1, lastName: 1, badgeDetails: 1 } },
	{ $sort: { createdAt: -1 } },
	{ $skip: skip },
	{ $limit: limit },
])
```

** Bad Example:**

```javascript
// Avoid chaining find with populate for complex queries
const users = await User.find({ isActive: true })
	.populate('badges')
	.sort({ createdAt: -1 })
	.skip(skip)
	.limit(limit)
```

### 3. Response Handling

Use the centralized response utilities from `utils/sendResponse.js` and`constants/httpStatus.js`.

** Good Example:**

```javascript
const sendResponse = require('../utils/sendResponse')
const HTTP = require('../constants/httpStatus')

router.get('/users', async (req, res) => {
	try {
		const users = await userService.getUsers()
		return sendResponse({
			res,
			status: true,
			code: HTTP.OK,
			data: users,
			message: 'Users retrieved successfully',
		})
	} catch (error) {
		return sendResponse({
			res,
			status: false,
			code: error.statusCode || HTTP.INTERNAL_SERVER_ERROR,
			data: null,
			message: error.message || 'Failed to retrieve users',
		})
	}
})
```

** Bad Example:**

```javascript
// Don't use hardcoded status codes
res.status(200).json({ success: true, data: users })
res.status(500).json({ error: 'Something went wrong' })
```

### 4. Error Handling

Use `ErrorHandler` class from `utils/errorHandler.js` and `catchAsyncError` middleware.

** Good Example:**

```javascript
const catchAsyncError = require('../middleware/catchAsyncError')
const ErrorHandler = require('../utils/errorHandler')
const HTTP = require('../constants/httpStatus')

// In routes
router.get('/users/:id', catchAsyncError(async (req, res, next) => {
const user = await userService.getUserById(req.params.id)
if (!user) {
  return next(new ErrorHandler('User not found', HTTP.NOT_FOUND))
}
// ... rest of handler
}))

// In services - throw errors to be caught by middleware
async getUserById(id) {
const user = await User.findById(id)
if (!user) {
  throw new ErrorHandler('User not found', HTTP.NOT_FOUND)
}
return user
}
```

### 5. Pagination

Use pagination utilities from`utils/pagination.js`.

** Good Example:**

```javascript
const { getPaginationParams, buildPaginatedResponse } = require('../utils/pagination')

async getUsers(query) {
const { page, limit, skip } = getPaginationParams(query)

const [users, totalResult] = await Promise.all([
  User.aggregate([
    { $match: { isActive: true } },
    { $skip: skip },
    { $limit: limit }
  ]),
  User.aggregate([
    { $match: { isActive: true } },
    { $count: 'total' }
  ])
])

const total = totalResult[0]?.total || 0
return buildPaginatedResponse(users, page, limit, total, 'users')
}
```

### 6. Constants - No Magic Values

All magic strings, numbers, and configuration values MUST be in `constants/` folder.

** Good Example:**

```javascript
// constants/user.js
module.exports = {
	USER_STATUS: {
		ACTIVE: 'active',
		INACTIVE: 'inactive',
		PENDING: 'pending',
		BLOCKED: 'blocked',
	},
	MAX_LOGIN_ATTEMPTS: 5,
	PASSWORD_MIN_LENGTH: 8,
	ROLES: {
		ADMIN: 'admin',
		USER: 'user',
		MODERATOR: 'moderator',
	},
}

// Usage in service
const { USER_STATUS, MAX_LOGIN_ATTEMPTS } = require('../constants/user')

if (user.status === USER_STATUS.BLOCKED) {
	throw new ErrorHandler('Account is blocked', HTTP.FORBIDDEN)
}
```

** Bad Example:**

```javascript
// Don't use magic strings/numbers
if (user.status === 'blocked') { ... }
if (loginAttempts > 5) { ... }
if (role === 'admin') { ... }

```

### 7. Middleware Usage

Apply middleware in route definitions from `middleware/` folder.

** Available Middleware:**

- `auth` - JWT authentication - `catchAsyncError` - Async error wrapper - `clientTypeMiddleware` - Detect mobile / web client - `geoipMiddleware` - Get user location - `requireSubscription` - Check subscription status - `validate` - Request validation

                ** Good Example:**
                  ```javascript

  const auth = require('../middleware/auth')
  const catchAsyncError = require('../middleware/catchAsyncError')
  const clientTypeMiddleware = require('../middleware/clientTypeMiddleware')

router.get(
'/protected-route',
[auth, clientTypeMiddleware],
catchAsyncError(async (req, res, next) => {
// Handler code
})
)

````

### 8. Route Organization

Keep routes thin - delegate to services for business logic.

** Good Example:**
```javascript
// routes/v1/app/route_app_user.js
const express = require('express')
const router = express.Router()
const userService = require('../../../services/user')
const auth = require('../../../middleware/auth')
const catchAsyncError = require('../../../middleware/catchAsyncError')
const sendResponse = require('../../../utils/sendResponse')
const HTTP = require('../../../constants/httpStatus')

router.get(
'/profile',
[auth],
catchAsyncError(async (req, res, next) => {
const userId = req.user.\_id.toString()
const profile = await userService.getProfile(userId)

    return sendResponse({
      res,
      status: true,
      code: HTTP.OK,
      data: profile,
      message: 'Profile retrieved successfully'
    })

})
)

module.exports = router

````

### 9. ObjectId Handling

Always convert ObjectId properly when using in aggregation.

** Good Example:**

```javascript
const mongoose = require('mongoose')

const userId = new mongoose.Types.ObjectId(req.user._id)

await User.aggregate([{ $match: { _id: userId } }])
```

### 10. Service Dependencies

Use dependency injection in service constructors.

** Good Example:**

```javascript
class PaymentService {
	constructor() {
		this.stripeService = require('./stripe/stripeService')
		this.notificationService = require('./notification')
	}

	async processPayment(userId, amount) {
		const payment = await this.stripeService.createPaymentIntent({ amount })
		await this.notificationService.sendPaymentNotification(userId, payment)
		return payment
	}
}

module.exports = new PaymentService()
```

## File Naming Conventions

- Routes: `route_{scope}_{resource}.js`(e.g., `route_app_user.js`, `route_admin_reports.js`)
  - Services: `{resource}Service.js` or`index.js` in folder(e.g., `userService.js`, `services/stripe/index.js`)
    - Constants: `{resource}.js`(e.g., `httpStatus.js`, `bible.js`)
      - Middleware: `{name}.js`(e.g., `auth.js`, `catchAsyncError.js`)

## JSDoc Documentation

Document all public methods with JSDoc.

```javascript
/**
 * Get user by ID with related data
 * @param {string} userId - The user's MongoDB ObjectId
 * @param {Object} options - Query options
 * @param {boolean} options.includeBadges - Include user badges
 * @returns {Promise<Object>} User object with related data
 * @throws {ErrorHandler} When user is not found
 */
async getUserById(userId, options = {}) {
  // Implementation
}
```

## Testing Considerations

- Services should be testable in isolation
  - Use dependency injection for external services
    - Avoid side effects in pure business logic functions

## Common Imports Template

```javascript
// Standard imports for routes
const express = require('express')
const router = express.Router()
const mongoose = require('mongoose')

// Middleware
const auth = require('../../../middleware/auth')
const catchAsyncError = require('../../../middleware/catchAsyncError')
const clientTypeMiddleware = require('../../../middleware/clientTypeMiddleware')

// Utils
const sendResponse = require('../../../utils/sendResponse')
const ErrorHandler = require('../../../utils/errorHandler')
const {
	getPaginationParams,
	buildPaginatedResponse,
} = require('../../../utils/pagination')

// Constants
const HTTP = require('../../../constants/httpStatus')

// Services
const userService = require('../../../services/user')
```

```javascript
// Standard imports for services
const mongoose = require('mongoose')
const ErrorHandler = require('../utils/errorHandler')
const HTTP = require('../constants/httpStatus')
const {
	getPaginationParams,
	buildPaginatedResponse,
} = require('../utils/pagination')

// Models
const { User } = require('../models/app/user_model')
```

## Security Best Practices

1. Always validate user input
2. Use parameterized queries(aggregation pipelines handle this)
3. Sanitize output data
4. Never expose internal error details in production
5. Use auth middleware for protected routes
6. Validate ObjectId format before queries

## Performance Guidelines

1. Use aggregation with $project to limit returned fields
2. Create indexes for frequently queried fields
3. Use pagination for list endpoints
4. Cache frequently accessed data(use Redis when available)
5. Avoid N + 1 queries - use $lookup in aggregation

## Legacy Code Migration Notes

### Constants Migration(contant.js → constants /)

The file`contant.js`(note the typo) at the root is legacy.
New constants should be added to the `constants/` folder.

** Current legacy imports to migrate:**

- `BADGES`, `STREAK_THRESHOLDS` → move to`constants/badges.js`
  - `HIATUS_THRESHOLD_DAYS` → move to`constants/user.js`
    - `HIGHLIGHT_COLORS` → already exists in `constants/bible.js`(update imports)
      - `RESTRICTED_PLATFORM` → move to`constants/platform.js`
        - `OTP_LIMIT` → move to`constants/auth.js`
          - `AI_GENERATION` → move to`constants/ai.js`
            - `TRANSCRIBE_*`, `VIDEO_*`, `LANGUAGE_CODE` → move to`constants/media.js`
              - `CPI_COURSE_ID`, `MAX_SESSION_LIMIT` → move to`constants/course.js`
                - `PAYMENT_TOKEN_EXPIRATION_TIME_HOURS` → move to`constants/payment.js`

                  ** When touching files that import from contant.js:**
                  1. Move the relevant constant to appropriate file in `constants/`

2. Update the import in the file you're modifying
3. Keep backward compatibility in `contant.js` by re - exporting from new location

Example migration:

```javascript
// constants/badges.js (new)
module.exports = {
	BADGES: {
		Mustard_Seed_Starter: '6710d34b150fc1ddc097f34e',
		// ... rest
	},
	STREAK_THRESHOLDS: {
		DAILY_BREAD: 7,
		STEADFAST_SERVANT: 10,
		BEACON_OF_LIGHT: 20,
		HEART_OF_GOLD: 30,
	},
}

// contant.js (keep for backward compatibility)
const badges = require('./constants/badges')
module.exports = {
	...badges,
	// ... other legacy exports
}
```

## Constants Organization by Domain

Organize constants in `constants/` folder by domain:

```
constants/
├── httpStatus.js      # HTTP status codes (existing)
├── bible.js           # Bible-related constants (existing)
├── s3.js              # S3/AWS constants (existing)
├── auth.js            # Authentication constants (OTP limits, token expiry)
├── badges.js          # Badge IDs and thresholds
├── user.js            # User-related constants (status, roles)
├── payment.js         # Payment and subscription constants
├── media.js           # Transcription, video processing
├── platform.js        # Platform identifiers (ios, android, web)
├── course.js          # Course-related constants
└── ai.js              # AI generation constants
```

## Response Helper Functions Reference

For convenience, here's a quick reference for response utilities that can be added globally:

```javascript
// In routes, you can create helper wrapper functions
const sendSuccess = (res, data, message, code = HTTP.OK, pagination = null) => {
	return sendResponse({
		res,
		status: true,
		code,
		data: pagination ? { ...data, pagination } : data,
		message,
	})
}

const sendError = (
	res,
	message,
	code = HTTP.INTERNAL_SERVER_ERROR,
	errorDetails = null
) => {
	return sendResponse({
		res,
		status: false,
		code,
		data: errorDetails,
		message,
	})
}

const sendValidationError = (res, message, data = null) => {
	return sendResponse({
		res,
		status: false,
		code: HTTP.BAD_REQUEST,
		data,
		message,
	})
}

const sendNotFound = (res, message = 'Resource not found') => {
	return sendResponse({
		res,
		status: false,
		code: HTTP.NOT_FOUND,
		data: null,
		message,
	})
}
```

## Validation Patterns

Use Joi or express - validator for request validation.

```javascript
const Joi = require('joi')
const validate = require('../middleware/validate')

const userSchema = Joi.object({
	email: Joi.string().email().required(),
	firstName: Joi.string().min(2).max(50).required(),
	lastName: Joi.string().min(2).max(50).required(),
	phone: Joi.string()
		.pattern(/^\+?[1-9]\d{1,14}$/)
		.optional(),
})

router.post(
	'/users',
	validate(userSchema),
	catchAsyncError(async (req, res, next) => {
		// req.body is now validated
	})
)
```

## Logging Best Practices

```javascript
// Good - contextual logging
console.error(`Error updating user ${userId}: `, error.message)
console.log(`User ${userId} completed reading for day ${dayNumber}`)

// Bad - vague logging
console.log('error')
console.log(error)
```

## Date / Timezone Handling

Always handle dates with user timezone awareness.

```javascript
const { fromZonedTime, formatInTimeZone } = require('date-fns-tz')
const { addDays } = require('date-fns')

// Get user's local midnight as UTC instant
async getUserDayWindowUtc(userId, dateString = null) {
  const user = await User.findById(userId)
  const tz = user?.timeZone || 'UTC'

  const ymd = dateString || new Date().toLocaleDateString('en-CA', { timeZone: tz })
  const startUtc = fromZonedTime(`${ ymd } 00:00:00`, tz)
  const endUtc = addDays(startUtc, 1)

  return { tz, ymd, startUtc, endUtc }
}
```

## Socket Event Patterns

For real - time updates, use the socket emitter service.

```javascript
const socketEmitter = require('../services/chat/socketEmitter')

// After database update
await message.save()
socketEmitter.emitMessageSent(message, conversationId)
```
